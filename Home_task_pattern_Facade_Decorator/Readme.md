## 1. Facade
https://medium.com/@dizaji.akbar/anti-patterns-that-assumed-as-pattern-part2-facade-2452ae6166b3
https://stackoverflow.com/questions/39079694/does-the-facade-pattern-violates-the-solid-principles

Якщо коротко рузюмувати з матеріалів в інтернеті:
1. Патерн Facade порушує другий принцип SOLID - OCP. Оскільки при додаванні нової підсистеми потрібно вносити правки в код фасаду. А за другим принципом повинна переважати можливість розширення, а не до зміни.
2. Facade більше підходить під функціональне програмування ніж під ООП. Оскільки будується на виконанні операцій а не роботи об'єктів. 

## 2. Decorator

### Decorator pattern
Суть методу декоратора.
Декоратор - це шаблон проектування, який дозволяє динамічно додавати поведінку до об’єкта. Це передбачає створення класу декоратора, який обгортає оригінальний об’єкт і надає додаткову функціональність, делегуючи деякі або всі операції об’єкту, що обгортає. Цей шаблон часто використовується для додавання нової поведінки до об’єкта без зміни його інтерфейсу. Об'єкт декоратора імплементує інтерфейс об'єкту. 

Тобто, Інтерфейс використання об'єкту чи декоратора для користуваа не змінюється, бо він той самий. Якщо об'єкт приймає параметер X типу Y, то і декоратор приймає такі самі параметри. 

Основа патерну декоратора є використання спільного інтерфейсу як для об'єкту так і для декоратора.

### LSP (Liskov substitution principle)

Liskov, Barbara: 
"Нехай ```q(x)``` є властивістю правильною для об'єктів ```x``` деякого типу ```T```. Тоді ```q(y)``` також має бути правильним для об'єктів ```y``` типу ```S```, де ```S``` — підтип типу ```T```."

Роберт С. Мартін: "Функції, які використовують базовий тип, повинні мати можливість використовувати підтипи базового типу, не знаючи про це."

Герб Саттер, Андрій Олександреску: "Підклас не повинен вимагати від коду, що викликає, більше, ніж базовий клас, і не повинен надавати коду, що викликає, менше, ніж базовий клас".

Якщо узагальнимо, то при виконанні принципу LSP - для виклику дочірнього класу не потрібно більше інформації ніж батьківський і повертає дочірній клас не менше інформації ніж батьківський

Підводячи підсумок, що при правильній реалізації шаблон декоратора Не порушує принципу заміни Ліскова. Головне, щоб клас декоратора дотримувався того самого інтерфейсу, що й вихідний об’єкт, і не створював жодної несподіваної поведінки, яка могла б порушити очікування клієнтів, які використовують інтерфейс оригінального об’єкта.